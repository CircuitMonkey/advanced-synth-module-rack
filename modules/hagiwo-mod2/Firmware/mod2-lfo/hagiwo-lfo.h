#ifndef HAGIWO_LFO_H
#define HAGIWO_LFO_H
/*
    Adapted as C++ class for Circuit Monkey ASMR MOD2 LFO module.
      
    This code is derived from:
      Hagiwo's MOD2 VCO Ver1.0
      available at:  https://note.com/solder_state/n/n2214749e92f2

    This code works much like Hagiwo's VCO module code except it has been
    optimized to produce LFO waveforms instead.   Frequency range is limited to
    less than 20 Hz.  Some new modes are added, like Random and Chunky Ramp.
    This code is intended to drive non-audible control voltages for wave modulation
    purposes.

      • Six discrete waveforms, chosen by POT 1 (A0) and switched by fixed ADC thresholds:
          0 – Sine 
          1 – Triangle 
          2 – Square (PolyBLEP) 
          3 – Saw (PolyBLEP)
          4 – Random
          5 – Chunky Ramp
      • PolyBLEP anti-aliasing on every hard-edge waveform (Square, Saw)
      • Additional 1-pole RC low-pass filter softens residual PWM / alias noise
      • Coarse tuning via POT 2 (A1); negative-slope 1 V/Oct CV on A2
      • TUNE_CAL compile-time constant (default = 1.000) multiplies the final frequency for easy front-panel calibration
      • (removed) Octave-shift push-button (GPIO 6) cycles through 0 / +1 / +2 / +3 octaves
      • 10-bit PWM audio (GPIO 1, channel B) at ≃36.6 kHz ISR rate
      • Wavetable resolution 1024 samples with linear interpolation
      • ISR-driven; second PWM slice (GPIO 2) only generates periodic interrupts


    --Pin assignments---
      POT1     A0       Waveform select (Sin / Tri / Squ / Saw / FM-4× / FM-2×)
      POT2     A1       Coarse tune
      POT3     A2       Frequency
      IN1      GPIO7    N/A
      IN2      GPIO0    N/A
      CV       A2       V/oct(Shared with POT3)
      BUTTON   GPIO6    change octave 0,+1,+2,+3
      OUT      GPIO1    10-bit PWM audio output (~36.6 kHz)
      LED      GPIO5    PWM representing amplitude of output
      EEPROM   N/A

  CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
  You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

  Some of the source code was generated by AI.

*/
#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>

class HagiwoLFO {
  public:
    HagiwoLFO();  // Constructor
    void begin();
    void loop();

    float freq;
    /* current waveform (0-5) and octave offset (0-3) */
    volatile uint8_t waveSel = 0; // 0=Sine, 1=Tri, 2=Square  , 3=Saw, 4=FMx4, 5=FMx2
    volatile uint8_t octShift = 0;  // to be removed.

  private:
    inline float polyBLEP(float t, float dt);
    void initTables();
    void __isr onPwmWrap();

    /* ========= Reference for ISR callback === Added by CircuitMonkey ========*/
    static const int SOC_TIMER_GROUP_TOTAL_TIMERS = 1;
    static HagiwoLFO *isrTable[];
    using isrFunct = void (*)();
    template<uint8_t NUM_INTERRUPTS = SOC_TIMER_GROUP_TOTAL_TIMERS>
    static isrFunct getIsr(uint8_t timerNumber);

    /* ============================== constants ============================== */
    static constexpr int TABLE_SIZE = 1024;       // must be power of two
    static constexpr float FULL_SCALE = 1023.0f;  // 10-bit PWM top
    static constexpr float MID_LEVEL = FULL_SCALE / 2.0f;

    static constexpr float SYS_CLK = 150'000'000.0f;  // 150 MHz default
    static constexpr int PWM_WRAP_IRQ = 4095;         // ≈36.6 kHz ISR rate

    /* base tuning range (front-panel pot A1) */
    static constexpr float TUNE_MIN_HZ = 0.2f;   // 0 % of the pot
    static constexpr float TUNE_RANGE_HZ = 60.0f;  // span 0 → 60 Hz

    /* frequency-calibration factor (edit here after measuring) */
    const float TUNE_CAL = 0.992f;  // 1.000 = no correction

    /* RC low-pass smoothing on the final sample (0 < α < 1) */
    static constexpr float LP_ALPHA = 0.18f;

    /* FM modulation depth in radians */
    volatile float fmAmount = 2.0f;

    /* ========================== hardware globals =========================== */
    uint sliceAudio;  // PWM slice for audio out
    uint sliceIRQ;    // PWM slice that triggers the ISR

    volatile uint16_t pwmSample = 0;
    volatile float phase = 0.0f;      // 0…TABLE_SIZE
    volatile float phaseStep = 0.0f;  // Δphase per ISR
    float sampleRate = 0.0f;          // ≈36.6 kHz

    /* ============================ wavetable =============================== */
    float tableSin[TABLE_SIZE];
    float tableTri[TABLE_SIZE];

};

template<uint8_t NUM_INTERRUPTS>
HagiwoLFO::isrFunct HagiwoLFO::getIsr(uint8_t timerNumber) {
  if (timerNumber == (NUM_INTERRUPTS - 1)) {
    return [] {
      isrTable[NUM_INTERRUPTS - 1]->onPwmWrap();
    };
  }
  return getIsr < NUM_INTERRUPTS - 1 > (timerNumber);
}

template<>
inline HagiwoLFO::isrFunct HagiwoLFO::getIsr<0>(uint8_t timerNumber) {
  (void) timerNumber;
  return nullptr;
}
#endif  // HAGIWO_LFO_H