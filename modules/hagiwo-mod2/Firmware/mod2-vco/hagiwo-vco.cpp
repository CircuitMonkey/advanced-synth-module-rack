/*
    Adapted as C++ class for Circuit Monkey ASMR MOD2 VCO module.
      
    This code is derived from:
      Hagiwo's MOD2 VCO Ver1.0
      available at:  https://note.com/solder_state/n/n2214749e92f2

      • Six discrete waveforms, chosen by POT 1 (A0) and switched by fixed ADC thresholds:
          0 – Sine 
          1 – Triangle 
          2 – Square (PolyBLEP) 
          3 – Saw (PolyBLEP)
          4 – FM-4×
          5 – FM-2×
      • PolyBLEP anti-aliasing on every hard-edge waveform (Square, Saw, both FM modes)
      • Additional 1-pole RC low-pass filter softens residual PWM / alias noise
      • Coarse tuning via POT 2 (A1); negative-slope 1 V/Oct CV on A2
      • TUNE_CAL compile-time constant (default = 1.000) multiplies the final frequency for easy front-panel calibration
      • Octave-shift push-button (GPIO 6) cycles through 0 / +1 / +2 / +3 octaves
      • FM depth set by fmAmount (radians) in the source; no CV assignment
      • 10-bit PWM audio (GPIO 1, channel B) at ≃36.6 kHz ISR rate
      • Wavetable resolution 1024 samples with linear interpolation
      • ISR-driven; second PWM slice (GPIO 2) only generates periodic interrupts


    --Pin assignments---
      POT1     A0       Waveform select (Sin / Tri / Squ / Saw / FM-4× / FM-2×)
      POT2     A1       Coarse tune
      POT3     A2       Frequency
      IN1      GPIO7    N/A
      IN2      GPIO0    N/A
      CV       A2       V/oct(Shared with POT3)
      BUTTON   GPIO6    change octave 0,+1,+2,+3
      OUT      GPIO1    10-bit PWM audio output (~36.6 kHz)
      LED      GPIO5    N/A
      EEPROM   N/A

  CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
  You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

  Some of the source code was generated by AI.

*/
#include "hagiwo-vco.h"

HagiwoVCO::HagiwoVCO() {
}

HagiwoVCO *HagiwoVCO::isrTable[SOC_TIMER_GROUP_TOTAL_TIMERS];

/* -----------------------------------------------------------------------
 *  PolyBLEP helper  (returns discontinuity correction)
 * -------------------------------------------------------------------- */
inline float HagiwoVCO::polyBLEP(float t, float dt) {
  if (t < dt)               { float x = t / dt;            return x + x - x*x - 1.0f; }
  if (t > 1.0f - dt)        { float x = (t - 1.0f) / dt;   return x*x + x + x + 1.0f; }
  return 0.0f;
}

/* -----------------------------------------------------------------------
 *  Build sine & triangle tables
 * -------------------------------------------------------------------- */
void HagiwoVCO::initTables() {
  for (int i = 0; i < TABLE_SIZE; ++i) {
    /* 0-centered sine, remapped to 0-1023 */
    tableSin[i] = MID_LEVEL + MID_LEVEL * sinf(2.0f * PI * i / TABLE_SIZE);

    /* triangle 0-to-FULL then back to 0 */
    if (i < TABLE_SIZE / 2)
      tableTri[i] = FULL_SCALE * i / ((TABLE_SIZE / 2) - 1);
    else
      tableTri[i] = FULL_SCALE * (TABLE_SIZE - 1 - i) / ((TABLE_SIZE / 2) - 1);
  }
}

/* =======================================================================
 *  PWM interrupt service routine
 * ==================================================================== */
void __isr HagiwoVCO::onPwmWrap() {
  /* pre-compute helpers shared by most algorithms */
  const int   idx      = static_cast<int>(phase) & (TABLE_SIZE - 1);
  const int   idxNext  = (idx + 1) & (TABLE_SIZE - 1);
  const float frac     = phase - idx;                  // 0…1 fractional
  const float tNorm    = phase / TABLE_SIZE;           // 0…1 normalised
  const float dtNorm   = phaseStep / TABLE_SIZE;       // phase increment (0<dt<1)

  float sample = MID_LEVEL;   // fallback value; will be overwritten

  switch (waveSel) {
    /* ---- 0 : Sine (table + linear interpolation) ------------------- */
    case 0: {
      sample = tableSin[idx] * (1.0f - frac) + tableSin[idxNext] * frac;
      break;
    }

    /* ---- 1 : Triangle --------------------------------------------- */
    case 1: {
      sample = tableTri[idx] * (1.0f - frac) + tableTri[idxNext] * frac;
      break;
    }

    /* ---- 2 : Square (PolyBLEP on both edges) ---------------------- */
    case 2: {
      float s = (tNorm < 0.5f) ? 1.0f : -1.0f;
      s +=  polyBLEP(tNorm, dtNorm);                          // rising edge
      s -=  polyBLEP(fmodf(tNorm + 0.5f, 1.0f), dtNorm);      // falling edge
      sample = MID_LEVEL + MID_LEVEL * s;
      break;
    }

    /* ---- 3 : Saw (PolyBLEP) -------------------------------------- */
    case 3: {
      float s = 2.0f * tNorm - 1.0f;       // raw saw −1…1
      s -= polyBLEP(tNorm, dtNorm);        // correct discontinuity
      sample = MID_LEVEL + MID_LEVEL * s;
      break;
    }

    /* ---- 4 : FM (modulator 4× carrier) --------------------------- */
    case 4: {
      /* modulator phase (wraps every 0…1) */
      float tMod = fmodf(tNorm * 4.0f, 1.0f);

      /* fast-table sine for the modulator */
      float posM   = tMod * TABLE_SIZE;
      int   idxM   = static_cast<int>(posM) & (TABLE_SIZE - 1);
      int   idxMN  = (idxM + 1) & (TABLE_SIZE - 1);
      float fracM  = posM - idxM;
      float modVal = tableSin[idxM] * (1.0f - fracM) + tableSin[idxMN] * fracM;
      float modN   = (modVal - MID_LEVEL) / MID_LEVEL;        // normalise –1…1

      /* carrier sine with phase modulation */
      float phaseRad = 2.0f * PI * tNorm + fmAmount * modN;
      float s        = sinf(phaseRad);
      sample = MID_LEVEL + MID_LEVEL * s;
      break;
    }

    /* ---- 5 : FM (modulator 2× carrier) --------------------------- */
    default:  {  // waveSel == 5 
      float tMod = fmodf(tNorm * 2.0f, 1.0f);

      float posM   = tMod * TABLE_SIZE;
      int   idxM   = static_cast<int>(posM) & (TABLE_SIZE - 1);
      int   idxMN  = (idxM + 1) & (TABLE_SIZE - 1);
      float fracM  = posM - idxM;
      float modVal = tableSin[idxM] * (1.0f - fracM) + tableSin[idxMN] * fracM;
      float modN   = (modVal - MID_LEVEL) / MID_LEVEL;

      float phaseRad = 2.0f * PI * tNorm + fmAmount * modN;
      float s        = sinf(phaseRad);
      sample = MID_LEVEL + MID_LEVEL * s;
      break;
    }
  }

  /* ---- simple RC low-pass (softens remaining alias / PWM texture) */
  static float lpState = MID_LEVEL;
  lpState += (sample - lpState) * LP_ALPHA;
  sample = lpState;

  /* ---- write to PWM duty cycle (10-bit) */
  pwmSample = static_cast<uint16_t>(sample + 0.5f);
  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, pwmSample);

  /* advance and wrap phase accumulator */
  phase += phaseStep;
  if (phase >= TABLE_SIZE)
    phase -= TABLE_SIZE;

  /* clear IRQ flag */
  pwm_clear_irq(sliceIRQ);
}

/* =======================================================================
 *  Hardware / PWM initialisation
 * ==================================================================== */
void HagiwoVCO::begin() {
  isrTable[0] = this;

  /* --- user inputs --------------------------------------------------- */
  pinMode(A0, INPUT);          // wave select
  pinMode(A1, INPUT);          // coarse tune
  pinMode(A2, INPUT);          // 1 V/Oct CV
  pinMode(6,  INPUT_PULLUP);   // octave shift button

  /* --- audio PWM out (pin-1) ---------------------------------------- */
  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  pwm_set_clkdiv(sliceAudio, 1);        // full 150 MHz / 1
  pwm_set_wrap  (sliceAudio, 1023);     // 10-bit wrap
  pwm_set_enabled(sliceAudio, true);

  /* --- second PWM channel triggers the ISR each wrap ---------------- */
  gpio_set_function(2, GPIO_FUNC_PWM);
  sliceIRQ = pwm_gpio_to_slice_num(2);
  pwm_clear_irq(sliceIRQ);
  pwm_set_irq_enabled(sliceIRQ, true);


 const uint8_t timerNumber = 0;
  //hw_timer_t *timer1ms = NULL;
  //timer1ms = timerBegin(timerNumber, 80, true);
  auto isr = getIsr(timerNumber);
  //timerAttachInterrupt(timer1ms, isr, true);

  irq_set_exclusive_handler(PWM_IRQ_WRAP, isr);
  //irq_set_exclusive_handler(PWM_IRQ_WRAP, HagiwoVCO::onPwmWrap);
 


  irq_set_enabled(PWM_IRQ_WRAP, true);
  pwm_set_clkdiv(sliceIRQ, 1);
  pwm_set_wrap  (sliceIRQ, PWM_WRAP_IRQ);
  pwm_set_enabled(sliceIRQ, true);

  /* --- precompute tables and sample rate ---------------------------- */
  sampleRate = SYS_CLK / (PWM_WRAP_IRQ + 1);
  initTables();
}

/* =======================================================================
 *  Main loop – handle UI and update frequency
 * ==================================================================== */
void HagiwoVCO::loop() {
  /* --- A0 : wave select thresholds ---------------------------------- */
  const int a0 = analogRead(A0);
  if      (a0 <  32) waveSel = 0; // Sine
  else if (a0 < 248) waveSel = 1; // Triangle
  else if (a0 < 514) waveSel = 2; // Square
  else if (a0 < 720) waveSel = 3; // Saw
  else if (a0 < 926) waveSel = 4; // FM 4×
  else                waveSel = 5;// FM 2×

  /* --- A1 : base frequency 320-410 Hz ------------------------------- */
  const float baseFreq =
      TUNE_MIN_HZ + TUNE_RANGE_HZ * analogRead(A1) / 1023.0f;

  /* --- A2 : external CV in octaves (negative slope) ----------------- */
  const float cvOct =
      -(analogRead(A2) / 1023.0f) * 8.3f * (33.0f / 55.0f) * TUNE_CAL;     ;

  /* --- push-button : 0 / +1 / +2 / +3 octave steps ------------------ */
  static int lastBtn = HIGH;
  int btn = digitalRead(6);
  if (lastBtn == HIGH && btn == LOW)
      octShift = (octShift + 1) & 3;   // modulo-4
  lastBtn = btn;

  /* --- final frequency calculation ---------------------------------- */
  freq = baseFreq * powf(2.0f, octShift + cvOct);
                // <<< calibration factor >>>

  /* --- update phase increment (table-index space per ISR) ----------- */
  phaseStep = freq * TABLE_SIZE / sampleRate;
}

