#ifndef HAGIWO_VCO_H
#define HAGIWO_VCO_H
/*
    Adapted as C++ class for Circuit Monkey ASMR MOD2 VCO module.
      
    This code is derived from:
      Hagiwo's MOD2 VCO Ver1.0
      available at:  https://note.com/solder_state/n/n2214749e92f2

      • Six discrete waveforms, chosen by POT 1 (A0) and switched by fixed ADC thresholds:
          0 – Sine 
          1 – Triangle 
          2 – Square (PolyBLEP) 
          3 – Saw (PolyBLEP)
          4 – FM-4×
          5 – FM-2×
      • PolyBLEP anti-aliasing on every hard-edge waveform (Square, Saw, both FM modes)
      • Additional 1-pole RC low-pass filter softens residual PWM / alias noise
      • Coarse tuning via POT 2 (A1); negative-slope 1 V/Oct CV on A2
      • TUNE_CAL compile-time constant (default = 1.000) multiplies the final frequency for easy front-panel calibration
      • Octave-shift push-button (GPIO 6) cycles through 0 / +1 / +2 / +3 octaves
      • FM depth set by fmAmount (radians) in the source; no CV assignment
      • 10-bit PWM audio (GPIO 1, channel B) at ≃36.6 kHz ISR rate
      • Wavetable resolution 1 024 samples with linear interpolation
      • ISR-driven; second PWM slice (GPIO 2) only generates periodic interrupts


    --Pin assignments---
      POT1     A0       Waveform select (Sin / Tri / Squ / Saw / FM-4× / FM-2×)
      POT2     A1       Coarse tune
      POT3     A2       Frequency
      IN1      GPIO7    N/A
      IN2      GPIO0    N/A
      CV       A2       V/oct(Shared with POT3)
      BUTTON   GPIO6    change octave 0,+1,+2,+3
      OUT      GPIO1    10-bit PWM audio output (~36.6 kHz)
      LED      GPIO5    N/A
      EEPROM   N/A

  CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
  You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

  Some of the source code was generated by AI.

*/
#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>

class HagiwoVCO {
  public:
    HagiwoVCO();  // Constructor
    void begin();
    void loop();

    float freq;
    /* current waveform (0-5) and octave offset (0-3) */
    volatile uint8_t waveSel = 0; // 0=Sine, 1=Tri, 2=Square  , 3=Saw, 4=FMx4, 5=FMx2
    volatile uint8_t octShift = 0;

  private:
    inline float polyBLEP(float t, float dt);
    void initTables();
    void __isr onPwmWrap();

    /* ========= Reference for ISR callback === Added by CircuitMonkey ========*/
    static const int SOC_TIMER_GROUP_TOTAL_TIMERS = 1;
    static HagiwoVCO *isrTable[];
    using isrFunct = void (*)();
    template<uint8_t NUM_INTERRUPTS = SOC_TIMER_GROUP_TOTAL_TIMERS>
    static isrFunct getIsr(uint8_t timerNumber);

    /* ============================== constants ============================== */
    static constexpr int TABLE_SIZE = 1024;       // must be power of two
    static constexpr float FULL_SCALE = 1023.0f;  // 10-bit PWM top
    static constexpr float MID_LEVEL = FULL_SCALE / 2.0f;

    static constexpr float SYS_CLK = 150'000'000.0f;  // 150 MHz default
    static constexpr int PWM_WRAP_IRQ = 4095;         // ≈36.6 kHz ISR rate

    /* base tuning range (front-panel pot A1) */
    static constexpr float TUNE_MIN_HZ = 320.0f;   // 0 % of the pot
    static constexpr float TUNE_RANGE_HZ = 90.0f;  // span 320 → 410 Hz

    /* frequency-calibration factor (edit here after measuring) */
    const float TUNE_CAL = 0.992f;  // 1.000 = no correction

    /* RC low-pass smoothing on the final sample (0 < α < 1) */
    static constexpr float LP_ALPHA = 0.18f;

    /* FM modulation depth in radians */
    volatile float fmAmount = 2.0f;

    /* ========================== hardware globals =========================== */
    uint sliceAudio;  // PWM slice for audio out
    uint sliceIRQ;    // PWM slice that triggers the ISR

    volatile uint16_t pwmSample = 0;
    volatile float phase = 0.0f;      // 0…TABLE_SIZE
    volatile float phaseStep = 0.0f;  // Δphase per ISR
    float sampleRate = 0.0f;          // ≈36.6 kHz

    /* ============================ wavetable =============================== */
    float tableSin[TABLE_SIZE];
    float tableTri[TABLE_SIZE];

};

template<uint8_t NUM_INTERRUPTS>
HagiwoVCO::isrFunct HagiwoVCO::getIsr(uint8_t timerNumber) {
  if (timerNumber == (NUM_INTERRUPTS - 1)) {
    return [] {
      isrTable[NUM_INTERRUPTS - 1]->onPwmWrap();
    };
  }
  return getIsr < NUM_INTERRUPTS - 1 > (timerNumber);
}

template<>
inline HagiwoVCO::isrFunct HagiwoVCO::getIsr<0>(uint8_t timerNumber) {
  (void) timerNumber;
  return nullptr;
}
#endif  // HAGIWO_VCO_H